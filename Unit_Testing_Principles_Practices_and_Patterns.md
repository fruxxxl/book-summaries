# Принципы юнит-тестирования
Автор: Владимир Хориков

## Определения и термины
1. **Корпоративное приложение** - приложение для автоматизации внутренних процессов компании.
2. **Программная энтропия** - снижение скорости разработки (энтропия - мера беспорядка в системе).
3. **MUT** - method under test.
4. **SUT** - system under test.
5. **Arrange/Act/Assert** - порядок выполнения теста: подготовка, действие, проверка.
6. **Недетерминированное поведение** - выдача разных результатов при перезапуске.
7. **Классическая школа тестирования** - тестируется единица поведения с изоляцией от других тестов. Мокаются только внешние зависимости (шина событий, SMTP, ext API).
8. **Лондонская школа** - тестируются единицы кода с изоляцией классов или функций. Мокаются все зависимости, кроме изменяемых (репозитории, сервисы и т.д.).
9. **Мать объектов (фабрика)** - создание объектов для тестовых целей.
10. **Построитель тестовых данных (билдер)** - создание структурированных тестовых данных.
11. **Нарушение инварианта** - нарушение логической целостности.
12. **Инкапсуляция** - защита от потенциальных нарушений инвариантов.
13. **Ложноотрицательное срабатывание** - пропущенные ошибки.
14. **Ложное срабатывание** - ложный сигнал тревоги.
15. **Метрика точности теста** - [сигнал] / [шум]. Точен, если сигнал хороший (способен находить ошибки), а шум минимальный (ложные срабатывания).
16. **Тестовая заглушка**
    - **Mock (spy)** - эмуляция выходного взаимодействия (отправка письма).
    - **Stub (dummy, fake)** - эмуляция входного взаимодействия (получение информации из базы).
17. **Overspecification** - излишняя спецификация, возникающая при проверке взаимодействий (в стабах).
18. **CQS** - command query separation - каждый метод должен быть либо командой, либо запросом, но не тем и не другим одновременно.
19. **Внутрисистемные взаимодействия** - связывают классы нашего приложения (являются деталями имплементации).
20. **Межсистемные взаимодействия** - это когда наше приложение общается с другими приложениями (являются наблюдаемым поведением).
21. **Ссылочная прозрачность (referential transparency)** - возможность замены метода соответствующим значением.
23. **Паттерн "простой объект"** - выделяет логику из переусложненного кода, в результате чего код становится настолько тривиальным, что не нуждается в тестировании. Выделенная логика перемещается в другой класс.
24. **Tell, don't ask** - принцип упаковки данных вместе с операциями над этими данными.
25. **CanExecute/Execute** - паттерн помогает консолидировать все решения на уровне предметной области и избавляет контроллер от них.
26. **Управляемые зависимости (внепроцессные зависимости под нашим контролем)** - доступны только нашему приложению и не видны внешнему миру (база данных).
27. **Неуправляемые зависимости (вне нашего контроля)** - видимые для других клиентов - SMTP, шина сообщений.
28. **FailFast принцип** - быстрое обнаружение ошибок в программе - альтернатива интеграционным тестам.
29. **YAQNI** - тебе это не нужно.
30. **Unit of Work** - объект, который обеспечивает выполнение транзакций над одним или несколькими источниками данных и поддерживает принцип атомарности операций.

## Мои выводы

1. Нужно тестировать не единицы кода, а части видимого поведения клиентов (классический подход). Клиенты на каждом уровне абстракции свои.
2. Замер покрытого кода (test coverage) как обязательство себя не оправдывает, так как создает ловушку уверенности (покрытие некачественными тестами-заглушками).
3. Код - обязательство, а не актив.
4. Если код тяжело покрыть тестами, это признак плохого дизайна.
5. Нужно использовать классический подход тестирования в юнит-тестах, чтобы не зависеть от деталей имплементации.
6. Секция действия должна состоять из одного вызова SUT, иначе это скорее всего признак нарушения инварианта.
7. Названия тестов должны быть понятны бизнесу (описывать поведение) и не должны быть сугубо техническими.
8. Фундаментальные аспекты тестов:
   - Защита от багов (тесты максимально используют весь рабочий код).
   - Устойчивость к рефакторингу (тесты не ломаются при рефакторинге, не хрупкие).
   - Быстрая обратная связь (тесты быстры и интегрированны в разработку).
   - Простота поддержки (тесты небольшие и понятные, а также чистые за счет разных паттернов).
9. Ложные срабатывания появляются в результате привязки тестов к деталям имплементации.
10. Принципиальное отличие: моки помогают эмулировать и *проверять* взаимодействия между тестируемой системой и ее зависимостями, а стабы - только эмулировать. Но библиотеки часто объединяют эти понятия в mock.
11. Использование моков для проверки внутрисистемных взаимодействий делает тесты хрупкими и должны использоваться только для межсистемных взаимодействий.
12. Функциональная архитектура не допускает побочных эффектов в ядре и выталкивает их на слой изменяемой оболочки.
13. Гексагональная архитектура не против побочных эффектов, производимых слоем предметной области, при условии, что они ограничены слоем этой области.
14. Функциональная архитектура сложнее и не всегда подходит.
15. Типы кода:
    - Модель предметной области и алгоритмы (сложный/глубокий, нет коллабораторов, пишем юнит-тесты).
    - Тривиальный код (не тестируем).
    - Контроллеры (простой/широкий, много коллабораторов, пишем интеграционные тесты).
    - Переусложненный код (рефакторим и разбиваем на домены и контроллеры).
16. Бизнес логику и координацию можно рассматривать в контексте глубины и ширины кода. Код может быть либо глубоким (сложным и важным), либо широким (работающим с многими коллабораторами), но никогда не должен быть и тем и другим.
17. Чем важнее и сложнее код, тем меньше у него должно быть коллабораторов.
18. Сложность кода определяется количеством точек принятия решений в коде.
19. Написание кода - дорогостоящий способ решения задач. Чем меньше кода требует решение и чем проще этот код, тем лучше.
20. Все проблемы в программировании можно решить путем добавления нового уровня абстракции (кроме проблемы наличия слишком большого количества абстракций).
21. Интеграционные тесты покрывают контроллеры, а юнит-тесты покрывают алгоритмы и доменную модель.
22. Пограничные случаи покрываются юнитами, а интеграционные тесты должны проходить по одному позитивному сценарию.
23. Используйте реальные экземпляры управляемых зависимостей в интеграционных тестах (база данных), заменяйте неуправляемые зависимости моками (SMTP, шина).
24. Интерфейсы с одной реализацией не нужны - это ошибка и нарушение YAGNI; исключение - моки.
25. Доменные события - полезный подход для изоляции от внепроцессных зависимостей в доменной области.
26. Всегда явно внедряйте зависимости.
27. Не полагайтесь на константы и литералы в тестах - пишите все эталоны с нуля, иначе это может привести к тавтологическим тестам.
28. Шпионы - это моки, написанные вручную.
29. Тесты не должны зависеть от состояния базы, они должны сами приводить его к нужному состоянию. Очистка базы перед тестом лучший вариант подготовки состояния.
30. Базу накатываем только миграциями.
31. Избегаем базы данных в памяти (mongo-memory-server, SQLite).
32. Вместо тестирования приватных методов, лучше использовать их косвенно - как часть наблюдаемого поведения. Если приватный метод сложен, то стоит задуматься о выделении его в отдельный класс.
33. Не ориентируйтесь ни на какую конкретную реализацию при написании тестов. Проверяйте рабочий код с точки зрения черного ящика, избегайте утечки знаний предметной области в тесты.


## Chat GPT выводы
### Анализ выводов из книги "Принципы юнит-тестирования" (Владимир Хориков):

#### 1. **Тестирование видимого поведения:**
   - Важно тестировать не только отдельные единицы кода, но и части видимого поведения клиентов. Рекомендуется использовать классический подход, где клиенты на разных уровнях абстракции имеют свои тесты.

#### 2. **О покрытии кода:**
   - Замер покрытия кода (test coverage) не всегда оправдывает себя, так как может создавать ловушку ложной уверенности. Необходимо избегать покрытия некачественными тестами-заглушками.

#### 3. **Качество кода и тестирование:**
   - Код должен быть обязательством, а не активом. Трудно тестируемый код может являться признаком плохого дизайна.

#### 4. **Принципы тестирования:**
   - Используйте классический подход тестирования в юнит-тестах, чтобы оставаться независимыми от деталей реализации.

#### 5. **Структура тестов:**
   - Секция действия в тесте должна содержать один вызов SUT (System Under Test), чтобы избежать нарушения инварианта.

#### 6. **Читаемость тестов:**
   - Названия тестов должны быть понятны бизнесу и не должны быть чрезмерно техническими.

#### 7. **Фундаментальные аспекты тестов:**
   - Тесты должны обеспечивать защиту от багов, быть устойчивыми к рефакторингу, обеспечивать быструю обратную связь и быть легкими в поддержке.

#### 8. **Использование моков и стабов:**
   - Моки помогают эмулировать и проверять взаимодействия, стабы — только эмулировать. Важно понимать различия и использовать соответственно.

#### 9. **Архитектурные принципы:**
   - Различные архитектурные стили (функциональная, гексагональная) предоставляют разные подходы к обработке побочных эффектов и сложности кода.

#### 10. **Типы кода и их тестирование:**
   - Различные типы кода (модель предметной области, тривиальный код, контроллеры, переусложненный код) требуют различных подходов к тестированию.

#### 11. **Интеграционные тесты и юнит-тесты:**
   - Интеграционные тесты покрывают контроллеры, а юнит-тесты покрывают алгоритмы и доменную модель. Пограничные случаи лучше тестировать с использованием юнит-тестов.

#### 12. **Использование реальных и моковых зависимостей:**
   - В интеграционных тестах лучше использовать реальные экземпляры управляемых зависимостей, заменяя неуправляемые зависимости моками.

#### 13. **Принцип "Черного ящика":**
   - Тесты следует ориентировать на рабочий код с точки зрения черного ящика, избегая утечек знаний предметной области в тесты.
